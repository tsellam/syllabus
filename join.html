<html>
  <link href="lib/bootstrap/css/bootstrap.min.css" rel="stylesheet" media="screen">
  <style>
    .row {
      margin-top: 1em;
    }
  </style>

  <body>
    <div class="container">
      <div class="row"><div class="col-md-12">
        <h3>Join Problem Generator</h3>
        <div class="row"><div class="col-md-5">
          Assumptions:
          <ul>
            <li>Joins are on the same attribute</li>
            <li>Join attr is a key in each table</li>
            <li>Indices are all on this attribute.</li>
            <li>Joins are not key-foreign key joins</li>
            <li>There's no cache</li>
          </ul>
          <p>
            Refresh the page to generate a new problem.
          </p>
          <button class="btn primary btn-xlarge" id="btn">Show Answer</button>
        </div>
        <div class="col-md-5">
          <div id="legend">
            <table class="table table-striped condensed small">
              <thead>
                <tr>
                  <th>Join Name</th>
                  <th>Description</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Hash-INL</td>
                  <td>Index nested loops using Hash Index</td>
                </tr>
                <tr>
                  <td>Primary-BTree-INL</td>
                  <td>Index nested loops using Primary BTree</td>
                </tr>
                <tr>
                  <td>Sec-BTree-INL</td>
                  <td>Index nested loops using Secondary BTree</td>
                </tr>
                <tr>
                  <td>NL</td>
                  <td>Nested loops</td>
                </tr>
                <tr>
                  <td>HashJoin</td>
                  <td>Hash Join</td>
                </tr>
              </tbody>
            </table>
          </div><!--/legend-->
        </div> </div>
      </div> </div>

      <div class="row"><div class="col-md-12">
        <div id="problem"></div>
      </div></div>
      <div class="row sol" style="display:none">
        <h4>Solutions</h4>
        <div class="col-md-6" style="">
          <div id="solution"></div>
        </div>
      </div>
    </div>
  </body>



  <script id="sol-template" type="text/x-handlebars-template">
    <div class="row"><div class="col-md-12">
      <code>{{solution}}</code>
    </div></div>
    <div class="row"><div class="col-md-12">
      {{#each joins}}
        <div class="row">
          <div class="col-md-6">
            {{result}} = {{outer}} {{jointype}} {{inner}}
          </div>
          <div class="col-md-6">
            <table class="table condensed small">
              <tr>
                <td>Result Cardinality</td>
                <td><mark>{{cardinality}}</mark></td>
              </tr>
              <tr>
                <td>Estimated Cost</td>
                <td><mark>{{joincost}}</mark></td>
              </tr>
            </table>
          </div>
        </div>
      {{/each}}

    </div></div>
    <div class="row"><div class="col-md-6">
    </div></div>
  </script>
  <script id="entry-template" type="text/x-handlebars-template">
    <div class="row">
      <div class="col-md-3">
        <h4>Stats</h4>
        <table class="table condensed small"><tbody>
          <tr><td>Fill Factor</td><td> <mark>{{stats.fillfactor}}</mark></td></tr>
          <tr><td><div>Dir Entry Size</td><td> <mark>{{stats.desize}}</mark> bytes</td></tr>
          <tr><td><div>Tuple Size</td><td> <mark>{{stats.tupsize}}</mark> bytes</td></tr>
          <tr><td><div>Page Size</td><td> <mark>{{stats.pagesize}}</mark> bytes</td></tr>
          <tr class="sol" style="display:none">
            <td>DE/Page</td>
            <td> <mark>floor(({{stats.pagesize}}*{{stats.fillfactor}}) / {{stats.desize}}) </mark>
          </td></tr>
          <tr class="sol" style="display:none">
            <td> Tups/Page</td>
            <td> <mark>floor(({{stats.pagesize}}*{{stats.fillfactor}}) / {{stats.tupsize}}) </mark>
          </td></tr>
        </tbody></table>
      </div>
      {{#each tables}}
        <div class="col-md-2">
          <h4>{{name}}</h4>
          <mark>{{card}}</mark> tuples<br/>
          <div class="sol" style="display: none">
            <mark>{{npages}}</mark> pages
          </div>
          {{#if hash}}hash index<br/>{{/if}}
          {{#if ptree}}primary tree index<br/>{{/if}}
          {{#if stree}}secondary tree index<br/>{{/if}}
        </div>
      {{/each}}
    </div>
  </script>

  <script src="./lib/underscore.js"></script>
  <script src="./lib/jquery.js"></script>
  <script src="./lib/handlebars.js"></script>
  <script src="lib/bootstrap.min.js"></script>
  <script>

    function randInt(min, max) {
      min = Math.ceil(min);
      max = Math.floor(max);
      return Math.floor(Math.random() * (max - min)) + min;
    }

    function randBool() {
      return Math.random() >= 0.5;
    }
    function randExp() {
      return Math.pow(10, randInt(1, 6));
    }
    function randItem(arr) {
      return arr[randInt(0, arr.length-1)];
    }

    function genTable(name) {
      var bHash = randBool();
      var bPBtree = randBool();
      var bSBtree = randBool();
      return {
        name: name,
        npages: randExp(),
        hash: bHash,
        ptree: bPBtree,
        stree: bSBtree
      };
    }
    function genStats() {
      var tupsize = randItem([10, 50, 100, 200]);

      return {
        fillfactor: randItem([0.25, 0.5, 0.8, 1]),
        desize: randItem([5]),
        tupsize: tupsize,
        pagesize: tupsize * randItem([5, 10, 20, 50])
      }
    }
    function log(base, y) {
      return Math.log(y) / Math.log(base);
    }

    function solve(tables, stats) {

      // compute access path costs 
      _.each(tables, function(t) { accessCosts(t, stats); });

      var seen = { };

      // bestJoin has the following structure:
      //    { outer: , inner: , jointype: ,cost: , card: }
      // where outer could be another join
      var bestJoin = {};

      // keep track of the sequence of joins that we pick
      var choices = [];

      // Pick the starting Join
      _.each(tables, function(o) {
        _.each(tables, function(i) {
          if (o == i) return;
          var join = joinCost(o, i, stats);
          if (_.isUndefined(bestJoin.cost) || join.cost < bestJoin.cost) {
            var npages = Math.ceil(_.min([o.card, i.card]) * stats.tupsize / (stats.fillfactor*stats.pagesize));
            join.npages = npages;
            bestJoin = join;
          }
        })
      });
      seen[bestJoin.outer.name] = 1;
      seen[bestJoin.inner.name] = 1;
      choices.push(bestJoin)

      // Grow the left-deep join
      while(_.size(seen) < tables.length) {
        // compute cost of every possible inner table
        var opts = _.compact(_.map(tables, function(t) {
          if (t.name in seen) return;
          return joinCost(bestJoin, t, stats);
        }));

        var join = _.min(opts, function(join) { return join.cost; });
        var mincard = _.min([bestJoin.card, join.inner.card]);
        var npages = Math.ceil(mincard * stats.tupsize / (stats.fillfactor*stats.pagesize));
        bestJoin = {
          outer: bestJoin,
          inner: join.inner,
          jointype: join.jointype,
          cost: join.cost,
          npages: npages,
          card: _.min([bestJoin.card, join.inner.card])
        };
        choices.push(_.clone(bestJoin));
        seen[join.inner.name] = 1;
      }
      return {
        bestJoin: bestJoin,
        choices: choices
      };
    }

    function linearizeJoinTree(tree) {
      var ret = [];
      while (!_.isUndefined(tree) && tree.inner) {
        ret.push(tree.inner.name)
        ret.push(tree.jointype)
        tree = tree.outer;
      }
      ret.push(tree.name);
      return ret.reverse()
    }


    function accessCosts(t, stats) {
      t.card = Math.floor(t.npages * (stats.fillfactor*stats.pagesize) / stats.tupsize);

      if (t.hash) {
        t.hashCost = 1;
      }
      if (t.ptree) {
        var height = Math.ceil(log((stats.fillfactor*stats.pagesize)/stats.desize, t.npages));
        t.ptreeCost = height + 1;
      }
      if (t.stree) {
        var tupsperpage = Math.floor((stats.fillfactor*stats.pagesize) / stats.tupsize);
        var desperpage = Math.floor((stats.fillfactor*stats.pagesize) / stats.desize);
        var height = Math.ceil(log(desperpage, Math.ceil(t.npages*tupsperpage/desperpage)));
        t.ptreeCost = height + 1 + 1;
      }
    }

    // Estimate the join costs
    function joinCost(outer, inner, stats) {
      var pairs = [
        ['Hash-INL', inner['hashCost']],
        ['Primary-BTree-INL', inner['ptreeCost']],
        ['Sec-BTree-INL', inner['streeCost']],
        ['NL', inner['npages']],
        ['HashJoin', 1]
      ];
      var outerCost = outer.cost || outer.npages;
      pairs = _.reject(pairs, function(p) { return _.isNaN(p[1]) || _.isUndefined(p[1]); });
      pairs = _.map(pairs, function(p) {
        if (p[0] == 'HashJoin') {
          return [p[0], outerCost + inner.npages + outer.card * p[1]];
        }
        return [p[0], outerCost + outer.card * p[1]];
      })
      var ret = _.min(pairs, function(p) { return p[1]; });
      return {
        inner: inner,
        outer: outer,
        jointype: ret[0],
        cost: ret[1],
        card: _.min([outer.card, inner.card])
      }
    }

    function genProblem() {
      var tables = _.times(4, function(i) { return genTable("T"+(i+1)); });
      var stats = genStats();

      var solution = solve(tables, stats);
      var tree = solution.bestJoin;
      var choices = solution.choices; //linearizeJoinTree(tree)


      //
      // 1. Render the problem 
      //
      $("#problem").html(genHTML("#entry-template", {
        tables: tables,
        stats: stats
      }));


      //
      // 2. Render the solutions
      //

      // 2.1 generate the string representation of the join plan
      var joinStr = [choices[0].outer.name];
      _.each(choices, function(choice) {
        joinStr.push([
          " ", choice.jointype, " ", choice.inner.name, ") "
        ]);
      });
      joinStr.unshift(_.times(choices.length, function(){return "("}));
      joinStr = _.flatten(joinStr).join("");

      // 2.2 generate a list of the joins
      var joins = [];
      _.each(choices, function(choice, idx) {
        var outer = "R"+idx;
        if (idx == 0) outer = choice.outer.name;
        joins.push({
          result: "R"+(idx+1),
          outer: outer,
          inner: choice.inner.name,
          jointype: choice.jointype,
          cardinality: choice.card,
          joincost: choice.cost
        });
      });

      $("#solution").html(genHTML("#sol-template", {
        solution: joinStr,
        card: tree.card,
        cost: tree.cost,
        joins: joins
      }));

      // instrument the button to toggle the solutions
      $("#btn").click(function() {
        $(".sol").toggle();
      })
      //$("#btn").click()
        
    }

    // helper to make using handlerbars easier
    function genHTML(elid, data) {
      var source   = $(elid).html();
      var template = Handlebars.compile(source);
      return template(data);
    }

    genProblem()
  </script>
</html>